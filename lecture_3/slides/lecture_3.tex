\documentclass[aspectratio=169]{beamer}
\usetheme{Madrid}
\usecolortheme{default}

\title{Lecture 3: Support Triage + API Actions}
\subtitle{Grounding, state, and safe external calls}
\author{University of Chicago}
\date{\today}

\begin{document}

\frame{\titlepage}

\section{AI Agents}

\begin{frame}{What is an AI Agent?}
\begin{itemize}
    \item An \textbf{AI Agent} is an LLM that can use \textbf{tools} to interact with the outside world
    \item While a basic LLM can only generate text based on its training data, an agent can:
    \begin{itemize}
        \item Query databases
        \item Call APIs
        \item Read files
        \item Execute code
        \item Search the web
        \item Perform actions in real-time
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{LLM vs Agent: Key Differences}
\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Aspect} & \textbf{LLM} & \textbf{Agent} \\
\hline
Capabilities & Text generation only & Text + tool usage \\
\hline
Knowledge & Training data only & Training data + real-time data \\
\hline
Actions & None & Can perform actions via tools \\
\hline
Interactivity & One-shot responses & Can loop and iterate \\
\hline
\end{tabular}
\end{table}
\end{frame}

\begin{frame}{Common Tool Categories}
\begin{itemize}
    \item \textbf{Database Tools}: Query databases, insert/update/delete records
    \item \textbf{API Tools}: Call REST APIs, interact with web services
    \item \textbf{File System Tools}: Read/write files, list directories
    \item \textbf{Code Execution Tools}: Run Python code, execute shell commands
    \item \textbf{Web Tools}: Search the web, scrape websites
\end{itemize}
\end{frame}

\begin{frame}{The Agent Loop}
\begin{center}
\Large
Observe $\rightarrow$ Think $\rightarrow$ Act $\rightarrow$ Observe $\rightarrow$ \ldots
\end{center}
\vspace{1cm}
\begin{enumerate}
    \item \textbf{Observe}: Receive input (user query, tool results, system state)
    \item \textbf{Think}: Process information and decide what to do next
    \item \textbf{Act}: Execute actions (call tools, generate responses)
    \item \textbf{Observe}: See the results and continue the loop
\end{enumerate}
\end{frame}

\begin{frame}{Example Agent Systems}
\begin{itemize}
    \item \textbf{LangChain Agents}
    \begin{itemize}
        \item Framework for building LLM applications
        \item Supports multiple LLM providers
        \item Tool integration and agent orchestration
    \end{itemize}
    \item \textbf{Claude with MCP} (Model Context Protocol)
    \begin{itemize}
        \item Claude Desktop can connect to MCP servers
        \item Access custom tools and data sources
    \end{itemize}
    \item \textbf{ChatGPT with Plugins/Code Interpreter}
    \item \textbf{Cursor AI}
\end{itemize}
\end{frame}

\section{Lecture 3: Support Triage + API Actions}

\begin{frame}{What you will build today}
\begin{itemize}
  \item A ticket triage pipeline (priority, category, route) using structured output
  \item A grounded draft response that cites a knowledge base (KB)
  \item A proposed action plan mapped to an allow-listed set of API calls
  \item A safe execution layer: validation + logging + failure handling
\end{itemize}
\end{frame}

\begin{frame}{Business problem}
\textbf{Scenario}: Customer support receives many tickets with uneven quality.
\vspace{0.4cm}

\textbf{Goal}: For each ticket, produce:
\begin{itemize}
  \item triage labels (priority/category/route)
  \item a grounded draft reply (citing KB snippets)
  \item \emph{optional} actions (create issue, refund request, CRM note) via APIs
\end{itemize}
\end{frame}

\begin{frame}{Inputs (provided in \texttt{lecture\_3/data})}
\begin{itemize}
  \item \texttt{tickets.jsonl}: support tickets
  \item \texttt{kb/}: short markdown KB articles
  \item \texttt{api\_stub\_data.json}: local ``API'' data used by stub calls
\end{itemize}
\end{frame}

\begin{frame}{New workflow primitive introduced}
\begin{itemize}
  \item \textbf{External actions}: turn model output into calls (safely!)
  \item \textbf{State}: tickets move through stages; we keep an audit log
\end{itemize}
\end{frame}

\begin{frame}{Pipeline}
\begin{enumerate}
  \item Parse ticket $\rightarrow$ triage JSON
  \item Retrieve relevant KB snippets (simple search) $\rightarrow$ context
  \item Draft reply with citations $\rightarrow$ JSON
  \item Propose actions $\rightarrow$ JSON (allow-listed)
  \item Validate + execute stub APIs; write logs
\end{enumerate}
\end{frame}

\begin{frame}{Exercises}
\begin{itemize}
  \item Improve routing accuracy with better prompts
  \item Reduce hallucinations by enforcing citations
  \item Add a ``safe executor'' that rejects invalid actions
  \item Add retry logic and better logs (what failed, why, what next)
\end{itemize}
\end{frame}

\begin{frame}{Deliverable}
\begin{itemize}
  \item Notebook: \texttt{notebooks/lecture\_3\_support\_triage\_api.ipynb}
  \item Output tables in \texttt{data/outputs/}:
    \begin{itemize}
      \item \texttt{triage.csv}, \texttt{draft\_replies.csv}, \texttt{actions\_log.csv}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Extensions / Optional challenges}
\begin{itemize}
  \item \textbf{Stronger grounding}: require exact quotes; reject replies that reference uncited facts
  \item \textbf{Better retrieval}: upgrade keyword overlap to embeddings or hybrid; measure impact on quality
  \item \textbf{Ticket state machine}: enforce allowed transitions (new $\rightarrow$ triaged $\rightarrow$ awaiting\_customer $\rightarrow$ resolved)
  \item \textbf{Safer execution}: per-action schema validation + dry-run mode + retry/backoff + richer logs
  \item \textbf{Adversarial tickets}: include prompt injection in ticket text; harden with instruction hierarchy + allow-lists
\end{itemize}
\end{frame}

\end{document}

